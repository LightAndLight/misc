# Why?

> Make it as simple as possible, but not simpler. (A. Einstein)
>
> &mdash; Niklaus Wirth

This project is inspired by Wirth's work on Pascal, Modula-2, and Oberon.
I've never worked with Pascal, so when I read some for the first time I was surprised by how capable the language was.
This comes after having looked at Wirth's Oberon operating system a few months earlier,
and being shocked by the claims he made about the simplicity of the system.

While I'm impressed by Pascal and its descendents, I don't want to use them.
My preferred style of programming is more "functional", inspired by Haskell and its anscestors.
I think there's a language that is to Haskell or OCaml as Pascal was to Algol.
That is to say: a vast simplification that loses nothing of importance.

So there's the exercise in simplicity for the "what".
I also have an exercise in simplicity for the "how".
At my job I've started noticing friction due to accidental complexity.
I suspect this compounds, so that progress developing a system will eventually stall unless there is a relentless and pervasive pursuit of simplicity.
I want to learn how to solve complex problems using simple tools.
While the essential complexity of a problem can't be erased,
I believe that a system can be built in ways where the parts themselves impose little complexity overhead.
It seems that when building a system, there are many ways to accidentally create new problems for a developer to solve on top of the one that originally motivated the code.
I want to practise *not doing that*.
